<?xml version="1.0" encoding="utf-8"?>
<topic id="112154ce-b000-48a3-a14a-f93fa302b719" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>The Connected Properties library does have some important limitations.</para>
    </introduction>
    <section address="NoEnumeration">
      <title>No Enumeration</title>
      <content>

<para>It is not possible to enumerate all properties connected to a given carrier object.</para>

<para>It is not possible to enumerate all carrier objects for a given connector.</para>

<para>As a result of this limitation, it is not possible to copy all connected properties from one carrier object to another; each property must be copied individually.</para>

      </content>
    </section>
    <section address="NotAGCCallback">
      <title>Not a GC Callback</title>
      <content>

<para>Since connected property values are not disposed, they cannot be used as an "object has been garbage collected" type of callback.</para>

      </content>
    </section>
    <section address="NoAtomicUpdate">
      <title>No Built-in Atomic Update</title>
      <content>

<para>Accessing connected properties is thread-safe. However, there is no operation that atomically updates the value based on the existing value (e.g., something similar to <codeEntityReference qualifyHint="true">Overload:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate</codeEntityReference> or <codeEntityReference qualifyHint="true">Overload:System.Threading.Interlocked.CompareExchange</codeEntityReference>).</para>

<para>If this type of functionality is needed, then you'll have to include it in the type of the property. E.g., you can define a connected property of type <codeEntityReference>T:System.Collections.Concurrent.ConcurrentDictionary`2</codeEntityReference>.</para>

      </content>
    </section>
  </developerConceptualDocument>
</topic>