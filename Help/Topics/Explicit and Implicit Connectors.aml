<?xml version="1.0" encoding="utf-8"?>
<topic id="e7b933e9-897f-45c1-9445-a7e284de6ee1" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>A <newTerm>connector</newTerm> is responsible for connecting a property to a carrier object. It acts like a property definition.</para>
    </introduction>
    <section address="ImplicitConnectors">
      <title>Implicit Connectors</title>
      <content>

<para>Add one or more sections with content</para>

<para>Implicit connectors exist as a <legacyItalic>type</legacyItalic>, and there are extension methods in <codeEntityReference qualifyHint="true">N:Nito.ConnectedProperties.Implicit</codeEntityReference> which allow accessing those properties on any carrier object. Part of an implicit connector's definition is a <newTerm>tag type</newTerm>, which is used to distinguish between different connected properties with the same value type.</para>

<para>The easiest way to demonstrate implicit connectors is by an example:</para>

<code language="C#">
<![CDATA[
using Nito.ConnectedProperties;
using Nito.ConnectedProperties.Implicit;

// Define a "tag" for our property definition.
private struct MyIntegerProperty { }

[TestMethod]
public void ConnectedPropertyMayBeRead()
{
  // Create a carrier object to connect our property to.
  object carrier = new object();

  // Set the "integer (MyIntegerProperty)" property on that carrier object (the property is connected to the carrier as a side-effect).
  carrier.GetConnectedProperty<int, MyIntegerProperty>().Set(13);

  // Read the "integer (MyIntegerProperty)" property from that carrier object.
  Assert.AreEqual(13, carrier.GetConnectedProperty<int, MyIntegerProperty>().Get());
}
]]>
</code>

<para>The <codeInline>MyIntegerProperty</codeInline> acts as a property definition "tag"; we could define another tag <codeInline>OtherIntegerProperty</codeInline> which is also an integer type, and that would be a different connected property.</para>

      </content>
    </section>
    <section address="ExplicitConnectors">
      <title>Explicit Connectors</title>
      <content>

<para>An explicit connector exists as an instance of <codeEntityReference qualifyHint="true">T:Nito.ConnectedProperties.Explicit.PropertyConnector`2</codeEntityReference>, where the first generic parameter is the type of carrier object and the second generic parameter is the type of the property value. Explicit connectors may choose to use any type of carrier object (by specifying the carrier type as <codeEntityReference>T:System.Object</codeEntityReference>), or they may choose to only connect to objects of a certain type or interface.</para>

<alert class="tip">
<para>If you're using explicit connectors and restricting carrier types, there is an interface for explicit connectors (<codeEntityReference qualifyHint="true">T:Nito.ConnectedProperties.Explicit.IPropertyConnector`2</codeEntityReference>), which is contravariant for the carrier type.</para>
</alert>

<para>You must manage the lifetime of explicit connectors. Here's an example of a test case using an explicit connector:</para>

<code language="C#">
<![CDATA[
using Nito.ConnectedProperties;
using Nito.ConnectedProperties.Explicit;

[TestMethod]
public void ConnectedPropertyMayBeRead()
{
  // Create the property connector: it can connect to any type of object, and its values are integers.
  var propertyDefinition = new PropertyConnector<object, int>();

  // Create a carrier object to connect our property to.
  object carrier = new object();

  // Set the property on that carrier object (the property is connected to the carrier as a side-effect).
  propertyDefinition.GetProperty(carrier).Set(13);

  // Read the property from that carrier object.
  Assert.AreEqual(13, propertyDefinition.GetProperty(carrier).Get());
}
]]>
</code>

      </content>
    </section>
    <section address="ChoosingBetweenExplicitAndImplicitConnectors">
      <title>Choosing Between Explicit and Implicit Connectors</title>
      <content>

<para>Implicit connectors have the following advantages:</para>

<list class="bullet">
<listItem>There is generally less code and less of a design impact, since the connector object itself doesn't have to be created and stored somewhere.</listItem>
<listItem>It's easier to share your connected properties with other parts of the code (you only have to expose your tag type, as opposed to passing around an actual connector object).</listItem>
</list>

<para>Explicit connectors have the following advantages:</para>

<list class="bullet">
<listItem>It's possible to restrict to a certain category of carrier objects by specifying the carrier type.</listItem>
<listItem>It's possible to dynamically create (and destroy) property connectors.</listItem>
<listItem>They are probably easier for most .NET programmers to understand.</listItem>
</list>

<para>Personally, I (Stephen Cleary) would choose implicit connectors unless I needed the dynamic creation of explicit connectors.</para>

<para>The Connected Properties library does provide full support for both types, and both connectors may connect to the same carrier object without any problems.</para>

      </content>
    </section>
  </developerConceptualDocument>
</topic>